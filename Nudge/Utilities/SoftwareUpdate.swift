//
//  SoftwareUpdate.swift
//  Nudge
//
//  Created by Rory Murdock on 2/10/21.
//

import Foundation
import os

class SoftwareUpdate {
    func list() -> String {
        let (output, error, exitCode) = runProcess(launchPath: "/usr/sbin/softwareupdate", arguments: ["--list", "--all"])

        if exitCode != 0 {
            LogManager.error("Error listing software updates: \(error)", logger: softwareupdateListLog)
            return error
        } else {
            LogManager.info("\(output)", logger: softwareupdateListLog)
            return output
        }
    }

    func download() {
        LogManager.notice("enforceMinorUpdates: \(OptionalFeatureVariables.enforceMinorUpdates)", logger: softwareupdateDownloadLog)

        if DeviceManager().getCPUTypeString() == "Apple Silicon" && !AppStateManager().requireMajorUpgrade() {
            LogManager.debug("Apple Silicon devices do not support automated softwareupdate downloads for minor updates. Please use MDM for this functionality.", logger: softwareupdateListLog)
            return
        }

        if AppStateManager().requireMajorUpgrade() {
            guard FeatureVariables.actionButtonPath == nil else { return }

            if OptionalFeatureVariables.attemptToFetchMajorUpgrade, !majorUpgradeAppPathExists, !majorUpgradeBackupAppPathExists {
                LogManager.notice("Device requires major upgrade - attempting download", logger: softwareupdateListLog)
                let (output, error, exitCode) = runProcess(launchPath: "/usr/sbin/softwareupdate", arguments: ["--fetch-full-installer", "--full-installer-version", OSVersionRequirementVariables.requiredMinimumOSVersion])

                if exitCode != 0 {
                    LogManager.error("Error downloading software update: \(error)", logger: softwareupdateDownloadLog)
                } else {
                    LogManager.info("\(output)", logger: softwareupdateDownloadLog)
                    GlobalVariables.fetchMajorUpgradeSuccessful = true
                    // Update the state based on the download result
                }
            } else {
                LogManager.notice("Found major upgrade application or backup - skipping download", logger: softwareupdateListLog)
            }
        } else {
            if OptionalFeatureVariables.disableSoftwareUpdateWorkflow {
                LogManager.notice("Skipping running softwareupdate because it's disabled by a preference.", logger: softwareupdateListLog)
                return
            }
            let softwareupdateList = self.list()
            let updateLabel = extractUpdateLabel(from: softwareupdateList)

            if !softwareupdateList.contains(OSVersionRequirementVariables.requiredMinimumOSVersion) || updateLabel.isEmpty {
                LogManager.notice("Software update did not find \(OSVersionRequirementVariables.requiredMinimumOSVersion) available for download - skipping download attempt", logger: softwareupdateListLog)
                return
            }

            LogManager.notice("Software update found \(updateLabel) available for download - attempting download", logger: softwareupdateListLog)
            let (output, error, exitCode) = runProcess(launchPath: "/usr/sbin/softwareupdate", arguments: ["--download", updateLabel])

            if exitCode != 0 {
                LogManager.error("Error downloading software updates: \(error)", logger: softwareupdateDownloadLog)
            } else {
                LogManager.info("\(output)", logger: softwareupdateDownloadLog)
            }
        }
    }

    private func extractUpdateLabel(from softwareupdateList: String) -> String {
        let lines = softwareupdateList.split(separator: "\n")
        var updateLabel: String?

        for line in lines {
            if line.contains("Label:") {
                let labelPart = line.split(separator: ":").map { $0.trimmingCharacters(in: .whitespaces) }
                if labelPart.count > 1 && labelPart[1].contains(OSVersionRequirementVariables.requiredMinimumOSVersion) {
                    updateLabel = labelPart[1]
                    break
                }
            }
        }

        return updateLabel ?? ""
    }

    private func runProcess(launchPath: String, arguments: [String]) -> (output: String, error: String, exitCode: Int32) {
        let task = Process()
        task.launchPath = launchPath
        task.arguments = arguments

        let outputPipe = Pipe()
        let errorPipe = Pipe()
        task.standardOutput = outputPipe
        task.standardError = errorPipe

        do {
            try task.run()
        } catch {
            return ("", "Error running process", -1)
        }

        task.waitUntilExit()

        let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
        let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()
        let output = String(decoding: outputData, as: UTF8.self)
        let error = String(decoding: errorData, as: UTF8.self)

        return (output, error, task.terminationStatus)
    }
}
